## ضمیمه الف: کلمات کلیدی

لیست زیر شامل کلمات کلیدی است که برای استفاده فعلی یا آینده توسط زبان Rust رزرو شده‌اند. به همین دلیل، نمی‌توان از آن‌ها به عنوان شناسه استفاده کرد (مگر به عنوان شناسه خام، همان‌طور که در بخش “[شناسه‌های خام][raw-identifiers]” توضیح داده خواهد شد). شناسه‌ها نام‌هایی هستند که برای توابع، متغیرها، پارامترها، فیلدهای ساختار، ماژول‌ها، جعبه‌ها (crates)، ثابت‌ها، ماکروها، مقادیر استاتیک، ویژگی‌ها، انواع، ویژگی‌ها، یا طول عمرها استفاده می‌شوند.

[raw-identifiers]: #raw-identifiers

### کلمات کلیدی در حال استفاده

فهرست زیر شامل کلمات کلیدی است که در حال حاضر استفاده می‌شوند، همراه با توضیح عملکرد آن‌ها:

- `as` - انجام تبدیل اولیه، مشخص کردن ویژگی خاص حاوی یک آیتم، یا تغییر نام آیتم‌ها در دستورات `use`
- `async` - بازگرداندن یک `Future` به جای مسدود کردن Thread فعلی
- `await` - متوقف کردن اجرا تا زمانی که نتیجه یک `Future` آماده شود
- `break` - خروج فوری از یک حلقه
- `const` - تعریف آیتم‌های ثابت یا اشاره‌گرهای خام ثابت
- `continue` - ادامه به تکرار بعدی حلقه
- `crate` - در مسیر ماژول، به ریشه crate اشاره دارد
- `dyn` - توزیع داینامیک به یک شیء ویژگی
- `else` - حالت جایگزین برای سازه‌های جریان کنترلی `if` و `if let`
- `enum` - تعریف یک شمارش
- `extern` - لینک کردن یک تابع یا متغیر خارجی
- `false` - مقدار بولی `false`
- `fn` - تعریف یک تابع یا نوع اشاره‌گر تابع
- `for` - حلقه بر روی آیتم‌های یک iterator، پیاده‌سازی یک ویژگی، یا مشخص کردن طول عمر سطح بالاتر
- `if` - انشعاب بر اساس نتیجه یک عبارت شرطی
- `impl` - پیاده‌سازی قابلیت‌های ذاتی یا ویژگی
- `in` - بخشی از سینتکس حلقه `for`
- `let` - متصل کردن یک متغیر
- `loop` - حلقه بدون شرط
- `match` - تطابق یک مقدار با الگوها
- `mod` - تعریف یک ماژول
- `move` - مالکیت متغیرهای گرفته‌شده توسط Closure را منتقل می‌کند
- `mut` - نشان دادن قابلیت تغییر در مراجع، اشاره‌گرهای خام، یا بایندینگ الگوها
- `pub` - نشان دادن قابلیت مشاهده عمومی در فیلدهای struct، بلوک‌های `impl`، یا ماژول‌ها
- `ref` - بایند کردن با مرجع
- `return` - بازگرداندن از تابع
- `Self` - یک نام مستعار برای نوعی که در حال تعریف یا پیاده‌سازی آن هستیم
- `self` - موضوع متد یا ماژول فعلی
- `static` - متغیر جهانی یا طول عمر طولانی تا زمان اجرای کامل برنامه
- `struct` - تعریف یک ساختار
- `super` - ماژول والد ماژول فعلی
- `trait` - تعریف یک ویژگی
- `true` - مقدار بولی `true`
- `type` - تعریف یک نام مستعار نوع یا نوع وابسته
- `union` - تعریف یک [union][union]<!-- ignore -->؛ فقط هنگام استفاده در یک اعلان union یک کلمه کلیدی است
- `unsafe` - نشان دادن کد، توابع، ویژگی‌ها یا پیاده‌سازی‌های ناامن
- `use` - آوردن نمادها به دامنه؛ مشخص کردن برداشت دقیق برای محدودیت‌های عمومی و طول عمر
- `where` - مشخص کردن بندهایی که یک نوع را محدود می‌کنند
- `while` - حلقه شرطی بر اساس نتیجه یک عبارت

[union]: ../reference/items/unions.html

### کلمات کلیدی رزرو شده برای استفاده در آینده

کلمات کلیدی زیر هنوز هیچ کاربردی ندارند اما توسط Rust برای استفاده احتمالی در آینده رزرو شده‌اند:

- `abstract`
- `become`
- `box`
- `do`
- `final`
- `gen`
- `macro`
- `override`
- `priv`
- `try`
- `typeof`
- `unsized`
- `virtual`
- `yield`

### شناسه‌های خام

_شناسه‌های خام_ سینتکسی هستند که به شما اجازه می‌دهند از کلمات کلیدی در جایی که معمولاً مجاز نیستند استفاده کنید. برای استفاده از یک شناسه خام، یک `r#` قبل از کلمه کلیدی اضافه کنید.

برای مثال، `match` یک کلمه کلیدی است. اگر بخواهید تابع زیر را که از `match` به عنوان نام خود استفاده می‌کند کامپایل کنید:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

شما این خطا را دریافت خواهید کرد:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

این خطا نشان می‌دهد که نمی‌توانید از کلمه کلیدی `match` به عنوان شناسه تابع استفاده کنید. برای استفاده از `match` به عنوان نام تابع، باید از سینتکس شناسه خام به این شکل استفاده کنید:

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

<span class="filename">Filename: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

این کد بدون هیچ خطایی کامپایل خواهد شد. به پیشوند `r#` روی نام تابع در تعریف آن و همچنین جایی که تابع در `main` فراخوانی می‌شود، توجه کنید.

شناسه‌های خام (_Raw identifiers_) به شما این امکان را می‌دهند که از هر کلمه‌ای که انتخاب می‌کنید به عنوان شناسه استفاده کنید، حتی اگر آن کلمه به‌طور معمول یک کلمه کلیدی رزرو‌شده باشد. این ویژگی آزادی بیشتری برای انتخاب نام شناسه‌ها فراهم می‌کند و همچنین امکان ادغام با برنامه‌هایی که به زبانی نوشته شده‌اند که این کلمات در آن زبان کلمات کلیدی نیستند، را می‌دهد. علاوه بر این، شناسه‌های خام به شما اجازه می‌دهند از کتابخانه‌هایی استفاده کنید که با نسخه‌ای از Rust نوشته شده‌اند که با نسخه مورد استفاده شما متفاوت است. 

برای مثال، `try` در نسخه ۲۰۱۵ کلمه کلیدی نیست، اما در نسخه‌های ۲۰۱۸، ۲۰۲۱ و ۲۰۲۴ کلمه کلیدی است. اگر به کتابخانه‌ای وابسته باشید که با نسخه ۲۰۱۵ نوشته شده و یک تابع به نام `try` دارد، باید از سینتکس شناسه خام، یعنی `r#try`، برای فراخوانی آن تابع از کد نسخه ۲۰۱۸ خود استفاده کنید. برای اطلاعات بیشتر در مورد نسخه‌ها به [ضمیمه ه][appendix-e]<!-- ignore --> مراجعه کنید.

شناسه‌های خام (Raw identifiers) به شما این امکان
را می‌دهند که از هر واژه‌ای به‌عنوان یک شناسه
استفاده کنید، حتی اگر آن واژه یک کلمه‌ی
رزرو‌شده باشد. این قابلیت، آزادی عمل بیشتری
برای انتخاب نام شناسه‌ها به ما می‌دهد و همچنین
امکان یکپارچه‌سازی با برنامه‌هایی که به زبانی نوشته
شده‌اند که این کلمات در آن‌ها رزرو‌شده نیستند
را فراهم می‌کند. علاوه بر این، شناسه‌های خام
به شما اجازه می‌دهند تا از کتابخانه‌هایی استفاده
کنید که با نگارشی متفاوت از crate شما نوشته
شده‌اند. برای مثال، `try` در نگارش ۲۰۱۵
کلمه‌ی کلیدی محسوب نمی‌شود، اما در نگارش‌های
۲۰۱۸، ۲۰۲۱ و ۲۰۲۴ یک کلمه‌ی کلیدی است.
اگر به کتابخانه‌ای وابسته باشید که با نگارش
۲۰۱۵ نوشته شده و تابعی با نام `try` دارد، برای
فراخوانی این تابع در کد خود (با نگارش‌های جدید)،
باید از نحو شناسه‌ی خام استفاده کنید، یعنی
`r#try`. برای اطلاعات بیشتر درباره‌ی نگارش‌ها
به [ضمیمه‌ی ه][appendix-e] مراجعه کنید.


[appendix-e]: appendix-05-editions.html

