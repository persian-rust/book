## خاموشی و پاک‌سازی منظم

کدی که در فهرست 21-20 آمده است، همان‌طور که انتظار داشتیم، با استفاده از یک thread pool به‌صورت asynchronous به درخواست‌ها پاسخ می‌دهد. در این میان، هشدارهایی در مورد فیلدهای `workers`، `id` و `thread` دریافت می‌کنیم که به‌طور مستقیم از آن‌ها استفاده نمی‌شود و این موضوع به ما یادآوری می‌کند که عملیات پاک‌سازی یا مدیریت پایانی انجام نشده است. زمانی که از روش نه‌چندان ظریف <kbd>Ctrl</kbd>+<kbd>C</kbd> برای متوقف کردن thread اصلی استفاده می‌کنیم، تمام threadهای دیگر نیز بلافاصله متوقف می‌شوند، حتی اگر در حال پردازش یک درخواست باشند.

سپس، ما `Drop` trait را پیاده‌سازی خواهیم کرد تا `join` را روی هر یک از نخ‌های موجود در مجموعه نخ فراخوانی کنیم تا بتوانند درخواست‌هایی که در حال کار روی آن‌ها هستند را قبل از بسته‌شدن تکمیل کنند. سپس روشی برای اطلاع به نخ‌ها که نباید درخواست‌های جدید بپذیرند و باید خاموش شوند، پیاده‌سازی خواهیم کرد. برای مشاهده عملکرد این کد، سرور خود را تغییر می‌دهیم تا فقط دو درخواست را قبل از خاموشی منظم مجموعه نخ‌ها بپذیرد.

چیزی که باید توجه داشته باشید این است که هیچ‌کدام از این موارد بخش‌هایی از کد را که مدیریت اجرای closureها را بر عهده دارند، تحت تأثیر قرار نمی‌دهند، بنابراین همه چیز در اینجا همان‌طور باقی می‌ماند اگر از یک مجموعه نخ برای یک runtime غیرهمزمان استفاده می‌کردیم.

### پیاده‌سازی `Drop` Trait روی `ThreadPool`

بیایید با پیاده‌سازی `Drop` روی مجموعه نخ شروع کنیم. وقتی مجموعه نخ حذف می‌شود، تمام نخ‌های ما باید به یکدیگر ملحق شوند تا مطمئن شویم کار خود را تکمیل می‌کنند. لیستینگ 21-22 اولین تلاش برای پیاده‌سازی `Drop` را نشان می‌دهد؛ این کد هنوز به درستی کار نخواهد کرد.

<Listing number="21-22" file-name="src/lib.rs" caption="ملحق کردن هر نخ وقتی مجموعه نخ از محدوده خارج می‌شود">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch21-web-server/listing-21-22/src/lib.rs:here}}
```

</Listing>

ابتدا، از میان تمام `worker`های موجود در thread pool یک حلقه اجرا می‌کنیم. از `&mut` استفاده می‌کنیم، زیرا `self` یک ارجاع قابل‌تغییر است و همچنین باید بتوانیم `worker` را نیز تغییر دهیم. برای هر `worker`، پیامی چاپ می‌کنیم که نشان دهد این نمونه‌ی خاص از `Worker` در حال خاموش شدن است، و سپس روی thread مربوط به همان `Worker` تابع `join` را فراخوانی می‌کنیم. اگر فراخوانی `join` با شکست مواجه شود، از `unwrap` استفاده می‌کنیم تا باعث panic در برنامه شود و خاموش شدن برنامه به‌صورت نامناسب انجام گیرد.


اینجا خطایی که هنگام کامپایل این کد دریافت می‌کنیم آمده است:

```console
{{#include ../listings/ch21-web-server/listing-21-22/output.txt}}
```

این خطا به ما می‌گوید که نمی‌توانیم `join` را فراخوانی کنیم زیرا فقط یک قرض قابل تغییر از هر `worker` داریم و `join` مالکیت آرگومان خود را می‌گیرد. برای حل این مشکل، باید نخ را از نمونه `Worker` که مالک `thread` است خارج کنیم تا `join` بتواند نخ را مصرف کند. یک راه برای انجام این کار استفاده از همان رویکردی است که در لیستینگ 18-15 استفاده کردیم. اگر `Worker` یک `Option<thread::JoinHandle<()>>` نگه می‌داشت، می‌توانستیم با استفاده از متد `take` مقدار را از نوع `Some` به نوع `None` منتقل کنیم.

با این حال، تنها زمانی که این مسئله مطرح می‌شود زمانی است که `Worker` حذف می‌شود. در عوض، باید با یک `Option<thread::JoinHandle<()>>` در همه جا سر و کار داشته باشیم. Rust ایدئوماتیک اغلب از `Option` استفاده می‌کند، اما زمانی که متوجه شوید چیزی را در `Option` قرار می‌دهید به عنوان یک راه‌حل موقت، حتی اگر بدانید آن مورد همیشه حضور دارد، ایده خوبی است که به دنبال روش‌های جایگزین باشید.

در این حالت، یک جایگزین بهتر استفاده از متد `Vec::drain` است. این متد یک پارامتر محدوده می‌گیرد تا مشخص کند کدام آیتم‌ها باید از `Vec` حذف شوند و یک تکرارگر از آن آیتم‌ها بازمی‌گرداند. استفاده از `..` برای محدوده تمام مقادیر را از `Vec` حذف خواهد کرد.

بنابراین باید پیاده‌سازی `drop` در `ThreadPool` را به این صورت به‌روزرسانی کنیم:

<Listing file-name="src/lib.rs">

```rust
{{#rustdoc_include ../listings/ch21-web-server/no-listing-04-update-drop-definition/src/lib.rs:here}}
```

</Listing>

این کار خطای کامپایلر را برطرف می‌کند و نیازی
به هیچ تغییر دیگری در کد ما ندارد. توجه داشته باشید
که از آن‌جا که drop می‌تواند هنگام panic فراخوانی شود،
تابع unwrap نیز ممکن است panic ایجاد کند و
باعث double panic شود که در نتیجه، برنامه
بلافاصله crash می‌کند و هرگونه عملیات پاک‌سازی
در حال انجام را متوقف می‌سازد. این موضوع برای یک
برنامه‌ی نمونه قابل قبول است، اما برای کدهای
محصولی توصیه نمی‌شود.


### علامت‌دهی به نخ‌ها برای توقف گوش دادن به وظایف

با تمام تغییراتی که اعمال کرده‌ایم، کد ما بدون هیچ
هشداری کامپایل می‌شود. اما خبر بد این است که
این کد هنوز آن‌طور که می‌خواهیم عمل نمی‌کند. نکته‌ی
کلیدی در منطق closureهایی است که توسط threadهای
نمونه‌های `Worker` اجرا می‌شوند: در حال حاضر
ما تابع `join` را فراخوانی می‌کنیم، اما این باعث
خاموش شدن threadها نمی‌شود، چون آن‌ها
به‌صورت بی‌پایان در حال `loop` برای یافتن job هستند.
اگر سعی کنیم `ThreadPool` را با پیاده‌سازی فعلی
تابع `drop` حذف کنیم، thread اصلی برای همیشه
در حالت انتظار باقی می‌ماند تا اولین thread به پایان برسد.

برای حل این مشکل، باید تغییری در پیاده‌سازی `drop` در `ThreadPool` و سپس تغییری در حلقه `Worker` ایجاد کنیم.

ابتدا پیاده‌سازی تابع `drop` برای `ThreadPool` را
تغییر می‌دهیم تا پیش از منتظر ماندن برای پایان یافتن
threadها، به‌صورت صریح `sender` را حذف کند.
فهرست 21-23 تغییرات اعمال‌شده روی `ThreadPool` را
نشان می‌دهد که در آن `sender` به‌طور صریح
حذف می‌شود. برخلاف thread، در این‌جا نیاز داریم
که از یک `Option` استفاده کنیم تا بتوانیم
`sender` را با استفاده از `Option::take` از
ساختار `ThreadPool` بیرون بکشیم.

<Listing number="21-23" file-name="src/lib.rs" caption="Explicitly dropping `sender` before joining the `Worker` threads">


```rust,noplayground,not_desired_behavior
{{#rustdoc_include ../listings/ch21-web-server/listing-21-23/src/lib.rs:here}}
```

</Listing>

حذف کردن `sender` باعث بسته شدن channel می‌شود،  
که این موضوع نشان می‌دهد دیگر هیچ پیامی ارسال  
نخواهد شد. در این حالت، تمام فراخوانی‌های `recv`  
که نمونه‌های `Worker` درون حلقه‌ی بی‌نهایت انجام  
می‌دهند با خطا بازمی‌گردند. در فهرست 21-24،  
حلقه‌ی `Worker` را طوری تغییر می‌دهیم که  
در چنین حالتی به‌صورت مناسب از حلقه خارج شود،  
که به این معناست threadها زمانی پایان می‌یابند که  
تابع `drop` مربوط به `ThreadPool` تابع `join` را  
روی آن‌ها فراخوانی کند.

<Listing number="21-24" file-name="src/lib.rs" caption="خروج صریح از حلقه زمانی که `recv` با خطا بازمی‌گردد">


```rust,noplayground
{{#rustdoc_include ../listings/ch21-web-server/listing-21-24/src/lib.rs:here}}
```

</Listing>

برای دیدن این کد در عمل، بیایید `main` را تغییر دهیم تا فقط دو درخواست را قبل از خاموش‌شدن منظم سرور بپذیرد، همان‌طور که در لیستینگ 21-25 نشان داده شده است.


<Listing number="21-25" file-name="src/main.rs" caption="خاموش کردن سرور پس از پاسخ‌گویی به دو درخواست از طریق خروج از حلقه">


```rust,ignore
{{#rustdoc_include ../listings/ch21-web-server/listing-21-25/src/main.rs:here}}
```

</Listing>

شما نمی‌خواهید یک سرور وب واقعی پس از فقط دو درخواست خاموش شود. این کد فقط نشان می‌دهد که خاموشی منظم و پاک‌سازی به درستی کار می‌کند.

متد `take` که در trait `Iterator` تعریف شده است، تکرار را به حداکثر دو آیتم محدود می‌کند. `ThreadPool` در انتهای `main` از محدوده خارج می‌شود و پیاده‌سازی `drop` اجرا خواهد شد.

سرور را با دستور `cargo run` راه‌اندازی کنید و سه درخواست ارسال کنید. درخواست سوم باید با خطا مواجه شود و در ترمینال خود باید خروجی مشابه زیر را ببینید:

<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->

```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
```

ممکن است ترتیب نمایش شناسه‌های `Worker` و
پیام‌های چاپ‌شده متفاوت باشد. از طریق این پیام‌ها
می‌توانیم بفهمیم کد چگونه کار می‌کند: نمونه‌های
`Worker` با شناسه‌های 0 و 3 اولین دو درخواست را
دریافت کرده‌اند. سرور پس از اتصال دوم،
پذیرفتن ارتباط‌های جدید را متوقف کرده و پیاده‌سازی
`Drop` برای `ThreadPool` پیش از آن‌که `Worker` 3
کار خود را آغاز کند اجرا شده است. حذف کردن
`sender` باعث قطع ارتباط تمامی نمونه‌های
`Worker` می‌شود و به آن‌ها اطلاع می‌دهد که
باید خاموش شوند. هر `Worker` هنگام قطع اتصال،
پیامی چاپ می‌کند و سپس thread pool تابع `join`
را فراخوانی می‌کند تا منتظر پایان thread مربوط به
هر `Worker` بماند.

به نکته‌ای جالب در این اجرای خاص توجه کنید:
`ThreadPool` ابتدا `sender` را حذف کرده و پیش از
آن‌که هیچ‌کدام از `Worker`ها خطایی دریافت کنند،
تلاش کرده‌ایم تا `Worker` 0 را join کنیم. در آن لحظه،
`Worker` 0 هنوز خطایی از `recv` دریافت نکرده
بود، بنابراین thread اصلی منتظر ماند تا `Worker` 0
به کار خود پایان دهد. در این فاصله، `Worker` 3
یک job دریافت کرد و سپس همه‌ی threadها
خطا دریافت کردند. وقتی `Worker` 0 به پایان رسید،
thread اصلی منتظر پایان سایر `Worker`ها ماند.
در آن لحظه، همه‌ی آن‌ها از حلقه‌ی خود خارج شده
و متوقف شده بودند.


تبریک می‌گویم! پروژه خود را کامل کردید؛ ما یک سرور وب ساده داریم که از یک مجموعه نخ برای پاسخ‌دهی غیرهمزمان استفاده می‌کند. ما توانستیم سرور را به صورت منظم خاموش کنیم و تمام نخ‌ها در مجموعه را پاک‌سازی کنیم.

در اینجا کد کامل برای مرجع آورده شده است:

<Listing file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch21-web-server/no-listing-07-final-code/src/main.rs}}
```

</Listing>

<Listing file-name="src/lib.rs">

```rust,noplayground
{{#rustdoc_include ../listings/ch21-web-server/no-listing-07-final-code/src/lib.rs}}
```

</Listing>

می‌توانستیم بیشتر اینجا انجام دهیم! اگر می‌خواهید این پروژه را بیشتر گسترش دهید، اینجا چند ایده آمده است:

- مستندات بیشتری به `ThreadPool` و متدهای عمومی آن اضافه کنید.
- تست‌هایی برای عملکرد کتابخانه اضافه کنید.
- فراخوانی‌های `unwrap` را به مدیریت خطای قوی‌تر تغییر دهید.
- از `ThreadPool` برای انجام برخی کارها به غیر از ارائه درخواست‌های وب استفاده کنید.
- یک crate مجموعه نخ از [crates.io](https://crates.io/) پیدا کنید و یک سرور وب مشابه با استفاده از آن crate پیاده‌سازی کنید. سپس API و مقاومت آن را با مجموعه نخی که ما پیاده‌سازی کردیم مقایسه کنید.

## خلاصه

آفرین! شما تا پایان این کتاب پیش آمده‌اید!
از اینکه در این سفر با ما همراه بودید صمیمانه
سپاسگزاریم. اکنون آماده‌اید تا پروژه‌های Rust
خودتان را پیاده‌سازی کنید و در پروژه‌های دیگران
نیز مشارکت داشته باشید. فراموش نکنید که
جامعه‌ای گرم و صمیمی از دیگر Rustaceanها
وجود دارد که با آغوش باز آماده‌اند در مسیر
یادگیری Rust به شما کمک کنند.

