## گسترش Cargo با دستورات سفارشی

با این حال، همچنان باید به‌صورت صریح نوع رفرنس پین‌شده را مشخص کنیم؛
در غیر این صورت، Rust نمی‌داند که این‌ها باید به عنوان trait objectهای داینامیک تفسیر شوند،
که این همان چیزی است که در `Vec` به آن نیاز داریم.
بنابراین، `pin` را به لیست واردات‌مان از `std::pin` اضافه می‌کنیم.
سپس می‌توانیم هر future را هنگام تعریف آن با `pin!` پین کنیم
و `futures` را به‌صورت یک `Vec` شامل رفرنس‌های mutable پین‌شده به نوع dynamic future تعریف کنیم،
همان‌طور که در لیستینگ 17-19 نشان داده شده است.

## خلاصه

اشتراک‌گذاری کد با Cargo و [crates.io](https://crates.io/)<!-- ignore --> بخشی از عواملی است که اکوسیستم Rust را برای بسیاری از وظایف مختلف مفید می‌کند. کتابخانه استاندارد Rust کوچک و پایدار است، اما crate‌ها به راحتی قابل اشتراک‌گذاری، استفاده و بهبود هستند و با یک خط زمانی متفاوت از زبان توسعه می‌یابند. از اشتراک‌گذاری کدی که برای شما مفید است در [crates.io](https://crates.io/)<!-- ignore --> خجالت نکشید؛ احتمالاً برای دیگران نیز مفید خواهد بود!
