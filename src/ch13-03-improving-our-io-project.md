## بهبود پروژه I/O

با این دانش جدید درباره iteratorها، می‌توانیم پروژه I/O در فصل ۱۲ را با استفاده از iteratorها بهبود بخشیم تا بخش‌هایی از کد واضح‌تر و مختصرتر شوند. بیایید ببینیم چگونه iteratorها می‌توانند پیاده‌سازی تابع `Config::build` و تابع `search` را بهبود دهند.

### حذف یک `clone` با استفاده از یک Iterator

در لیست 12-6، کدی اضافه کردیم که یک برش از مقادیر `String` را گرفته و یک نمونه از ساختار `Config` ایجاد می‌کرد. این کار با شاخص‌گذاری در برش و کلون کردن مقادیر انجام شد تا ساختار `Config` مالک آن مقادیر شود. در لیست 13-17، پیاده‌سازی تابع `Config::build` را همانطور که در لیست 12-23 بود بازتولید کرده‌ایم:

<Listing number="13-17" file-name="src/lib.rs" caption="بازتولید تابع `Config::build` از لیست 12-23">

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-23-reproduced/src/main.rs:ch13}}
```

</Listing>

در آن زمان گفتیم که نگران تماس‌های ناکارآمد `clone` نباشید زیرا در آینده آن‌ها را حذف خواهیم کرد. خب، اکنون زمان آن فرا رسیده است!

ما در اینجا به `clone` نیاز داشتیم زیرا در پارامتر `args` یک برش با عناصر `String` داریم، اما تابع `build` مالک `args` نیست. برای بازگرداندن مالکیت یک نمونه `Config`، مجبور بودیم مقادیر فیلدهای `query` و `file_path` را از `Config` کلون کنیم تا نمونه `Config` بتواند مالک مقادیرش باشد.

با دانش جدیدمان درباره iteratorها، می‌توانیم تابع `build` را تغییر دهیم تا مالکیت یک iterator را به عنوان آرگومان خود بگیرد، به جای اینکه یک برش را قرض بگیرد. ما از قابلیت‌های iterator به جای کدی که طول برش را بررسی می‌کند و به مکان‌های خاص شاخص می‌زند، استفاده خواهیم کرد. این کار مشخص می‌کند که تابع `Config::build` چه کاری انجام می‌دهد زیرا iterator به مقادیر دسترسی پیدا خواهد کرد.

زمانی که `Config::build` مالکیت iterator را به دست آورد و استفاده از عملیات شاخص‌گذاری که قرض می‌گیرند را متوقف کرد، می‌توانیم مقادیر `String` را از iterator به `Config` منتقل کنیم به جای اینکه `clone` را فراخوانی کنیم و تخصیص جدیدی ایجاد کنیم.

#### استفاده مستقیم از Iterator بازگردانده‌شده

فایل _src/main.rs_ پروژه I/O خود را باز کنید، که باید به این شکل باشد:

<span class="filename">نام فایل: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-24-reproduced/src/main.rs:ch13}}
```

ابتدا شروع تابع `main` که در لیست 12-24 داشتیم را به کدی که در لیست 13-18 است تغییر می‌دهیم، که این بار از یک iterator استفاده می‌کند. این کد تا زمانی که `Config::build` را نیز به‌روزرسانی کنیم، کامپایل نخواهد شد.

<Listing number="13-18" file-name="src/main.rs" caption="ارسال مقدار بازگردانده‌شده توسط `env::args` به `Config::build`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-18/src/main.rs:here}}
```

</Listing>

تابع `env::args` یک iterator بازمی‌گرداند! به جای جمع‌آوری مقادیر iterator در یک وکتور و سپس ارسال یک برش به `Config::build`، اکنون ما مالکیت iterator بازگردانده‌شده از `env::args` را مستقیماً به `Config::build` ارسال می‌کنیم.

سپس باید تعریف تابع `Config::build` را به‌روزرسانی کنیم. در فایل _src/lib.rs_ پروژه I/O خود، امضای تابع `Config::build` را به شکلی که در لیست 13-19 نشان داده شده تغییر دهید. این کد هنوز کامپایل نخواهد شد زیرا باید بدنه تابع را نیز به‌روزرسانی کنیم.

<Listing number="13-19" file-name="src/lib.rs" caption="به‌روزرسانی امضای `Config::build` برای انتظار یک iterator">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-19/src/main.rs:here}}
```

</Listing>

مستندات کتابخانه استاندارد برای تابع `env::args` نشان می‌دهد که نوع iterator بازگردانده‌شده `std::env::Args` است، و این نوع صفت `Iterator` را پیاده‌سازی کرده و مقادیر `String` بازمی‌گرداند.

ما امضای تابع `Config::build` را به‌روزرسانی کرده‌ایم تا پارامتر `args` یک نوع جنریک با محدودیت‌های صفت `impl Iterator<Item = String>` باشد به جای `&[String]`. این استفاده از نحو `impl Trait` که در بخش [“Traits به عنوان پارامترها”][impl-trait]<!-- ignore --> فصل 10 بحث شد، به این معناست که `args` می‌تواند هر نوعی باشد که صفت `Iterator` را پیاده‌سازی کرده و آیتم‌های `String` بازمی‌گرداند.

از آنجا که مالکیت `args` را به دست می‌آوریم و با پیمایش در آن، `args` را تغییر خواهیم داد، می‌توانیم کلمه کلیدی `mut` را به مشخصات پارامتر `args` اضافه کنیم تا آن را قابل تغییر کنیم.

#### استفاده از متدهای صفت `Iterator` به جای شاخص‌گذاری

سپس بدنه تابع `Config::build` را اصلاح می‌کنیم. از آنجا که `args` صفت `Iterator` را پیاده‌سازی کرده است، می‌دانیم که می‌توانیم متد `next` را روی آن فراخوانی کنیم! لیست 13-20 کد لیست 12-23 را برای استفاده از متد `next` به‌روزرسانی می‌کند:

<Listing number="13-20" file-name="src/lib.rs" caption="تغییر بدنه `Config::build` برای استفاده از متدهای iterator">

```rust,ignore,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-20/src/main.rs:here}}
```

</Listing>

به یاد داشته باشید که اولین مقدار در مقدار بازگردانده‌شده از `env::args` نام برنامه است. ما می‌خواهیم آن را نادیده بگیریم و به مقدار بعدی برسیم، بنابراین ابتدا `next` را فراخوانی می‌کنیم و هیچ کاری با مقدار بازگشتی انجام نمی‌دهیم. سپس، `next` را فراخوانی می‌کنیم تا مقداری که می‌خواهیم در فیلد `query` از `Config` قرار دهیم را دریافت کنیم. اگر `next` یک `Some` بازگرداند، از یک `match` برای استخراج مقدار استفاده می‌کنیم. اگر `None` بازگرداند، به این معنی است که آرگومان‌های کافی ارائه نشده‌اند و با مقدار `Err` زودتر بازمی‌گردیم. همین کار را برای مقدار `file_path` انجام می‌دهیم.

### واضح‌تر کردن کد با تطبیق‌دهنده‌های Iterator

ما همچنین می‌توانیم از iteratorها در تابع `search` پروژه I/O خود بهره ببریم. این تابع در لیست 13-21 به همان شکلی که در لیست 12-19 بود بازتولید شده است:

<Listing number="13-21" file-name="src/lib.rs" caption="پیاده‌سازی تابع `search` از لیست 12-19">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:ch13}}
```

</Listing>

ما می‌توانیم این کد را با استفاده از متدهای تطبیق‌دهنده iterator به شکلی مختصرتر بنویسیم. این کار همچنین به ما اجازه می‌دهد که از داشتن یک وکتور میانی قابل تغییر به نام `results` اجتناب کنیم. سبک برنامه‌نویسی تابعی ترجیح می‌دهد مقدار حالت‌های قابل تغییر را به حداقل برساند تا کد واضح‌تر شود. حذف حالت قابل تغییر ممکن است امکان ارتقاء آینده را فراهم کند تا جستجو به صورت موازی انجام شود، زیرا نیازی به مدیریت دسترسی همزمان به وکتور `results` نخواهیم داشت. لیست 13-22 این تغییر را نشان می‌دهد:

<Listing number="13-22" file-name="src/lib.rs" caption="استفاده از متدهای تطبیق‌دهنده iterator در پیاده‌سازی تابع `search`">

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-22/src/lib.rs:here}}
```

</Listing>

به یاد دارید که هدف تابع `search` این است که تمام خطوط موجود در `contents` را که شامل `query` هستند برگرداند. مشابه با مثال `filter` در لیستینگ 13-16، این کد از آداپتور `filter` استفاده می‌کند تا فقط خطوطی را نگه دارد که در آن‌ها `line.contains(query)` مقدار `true` را بازمی‌گرداند. سپس خطوط مطابق را با استفاده از `collect` در یک وکتور جدید جمع‌آوری می‌کنیم. خیلی ساده‌تر! شما می‌توانید همین تغییر را در تابع `search_case_insensitive` نیز اعمال کرده و از متدهای پیمایشگر استفاده کنید.

برای بهبود بیشتر، مقدار بازگشتی تابع `search` را به‌جای وکتور، یک پیمایشگر قرار دهید؛ با حذف فراخوانی `collect` و تغییر نوع بازگشتی به `impl Iterator<Item = &'a str>`، این تابع به یک آداپتور پیمایشگر تبدیل می‌شود. توجه داشته باشید که باید تست‌ها را نیز مطابق این تغییر به‌روزرسانی کنید! یک فایل بزرگ را با ابزار `minigrep` خود، قبل و بعد از این تغییر جست‌وجو کنید تا تفاوت رفتار را مشاهده نمایید. قبل از این تغییر، برنامه تا زمانی که تمام نتایج جمع‌آوری نشده‌اند چیزی چاپ نمی‌کند، اما پس از این تغییر، نتایج به‌محض یافتن هر خط مطابق چاپ می‌شوند، زیرا حلقه `for` در تابع `run` می‌تواند از ویژگی تنبلی پیمایشگر استفاده کند.

<a id="choosing-between-loops-or-iterators"></a>

### انتخاب بین حلقه‌ها و پیمایشگرها

سؤال منطقی بعدی این است که کدام سبک را در کد خود انتخاب کنیم و چرا: پیاده‌سازی اولیه در لیستینگ 13-21 یا نسخه‌ای که از پیمایشگرها استفاده می‌کند در لیستینگ 13-22 (با فرض اینکه تمام نتایج را پیش از بازگرداندن جمع‌آوری می‌کنیم و نه اینکه خود پیمایشگر را بازگردانیم). بیشتر برنامه‌نویسان Rust ترجیح می‌دهند از سبک پیمایشگر استفاده کنند. در ابتدا ممکن است درک آن کمی دشوارتر باشد، اما زمانی که با آداپتورهای مختلف پیمایشگر و عملکرد آن‌ها آشنا شدید، کار با آن‌ها آسان‌تر خواهد بود. به جای کلنجار رفتن با بخش‌های مختلف حلقه و ساخت وکتورهای جدید، کد روی هدف سطح بالای حلقه تمرکز می‌کند. این امر باعث پنهان شدن بخشی از کدهای تکراری شده و فهم مفاهیم خاص این کد (مانند شرط فیلتر شدن هر عنصر پیمایشگر) را آسان‌تر می‌کند.

اما آیا این دو پیاده‌سازی واقعاً معادل هم هستند؟ فرض شهودی ممکن است این باشد که حلقه سطح پایین‌تر سریع‌تر است. بیایید درباره عملکرد صحبت کنیم.

[impl-trait]: ch10-02-traits.html#traits-as-parameters
